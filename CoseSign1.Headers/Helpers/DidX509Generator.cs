// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

namespace CoseSign1.Headers.Helpers;

using System.Linq;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;

/// <summary>
/// Generates DID:X509 identifiers from X.509 certificates according to the specification at
/// https://github.com/microsoft/did-x509/blob/main/specification.md
/// </summary>
/// <remarks>
/// DID:X509 identifiers generated by CoseSignTool follow these formats:
/// - If non-standard EKU is present: did:x509:0:sha256:{rootCertHash}::eku:{encodedEkuOid}
/// - If only standard EKUs: did:x509:0:sha256:{rootCertHash}::subject:{encodedLeafSubject}
/// This provides a cryptographically verifiable decentralized identifier based on X.509 PKI.
/// Note: The DID:X509 specification supports additional query parameters beyond what CoseSignTool generates.
/// </remarks>
public static class DidX509Generator
{
    private const string DidX509Prefix = "did:x509:0:sha256";

    // Standard EKU OIDs that are considered "standard" uses
    private static readonly HashSet<string> StandardEkuOids = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
        "1.3.6.1.5.5.7.3.1",  // TLS Server Authentication
        "1.3.6.1.5.5.7.3.2",  // TLS Client Authentication
        "1.3.6.1.5.5.7.3.3",  // Code Signing
        "1.3.6.1.5.5.7.3.4",  // Email Protection
        "1.3.6.1.5.5.7.3.8",  // Time Stamping
    };

    /// <summary>
    /// Generates a DID:X509 identifier from a leaf certificate and root certificate.
    /// Uses ::eku: query parameter if non-standard EKUs are present, otherwise uses ::subject:.
    /// </summary>
    /// <param name="leafCertificate">The leaf certificate (end-entity certificate).</param>
    /// <param name="rootCertificate">The root certificate (trust anchor).</param>
    /// <returns>A DID:X509 formatted identifier.</returns>
    /// <exception cref="ArgumentNullException">Thrown when either certificate is null.</exception>
    public static string Generate(X509Certificate2 leafCertificate, X509Certificate2 rootCertificate)
    {
        if (leafCertificate == null)
        {
            throw new ArgumentNullException(nameof(leafCertificate));
        }

        if (rootCertificate == null)
        {
            throw new ArgumentNullException(nameof(rootCertificate));
        }

        // Calculate SHA256 hash of root certificate's raw data
        byte[] rootCertHash;
        using (SHA256 sha256 = SHA256.Create())
        {
            rootCertHash = sha256.ComputeHash(rootCertificate.RawData);
        }
        string rootCertHashHex = BitConverter.ToString(rootCertHash).Replace("-", "").ToLowerInvariant();

        // Check for non-standard EKUs
        string? nonStandardEku = GetNonStandardEku(leafCertificate);
        
        if (nonStandardEku != null)
        {
            // Use ::eku: query parameter for non-standard EKUs
            // Format: did:x509:0:sha256:{rootHash}::eku:{encodedEku}
            string encodedEku = EncodeSubject(nonStandardEku);
            return $"{DidX509Prefix}:{rootCertHashHex}::eku:{encodedEku}";
        }
        else
        {
            // Use ::subject: for standard EKUs only
            // Format: did:x509:0:sha256:{rootHash}::subject:{encodedSubject}
            string encodedSubject = EncodeSubject(leafCertificate.Subject);
            return $"{DidX509Prefix}:{rootCertHashHex}::subject:{encodedSubject}";
        }
    }

    /// <summary>
    /// Generates a DID:X509 identifier from a certificate chain.
    /// </summary>
    /// <param name="certificates">The certificate chain. First certificate must be the leaf.</param>
    /// <returns>A DID:X509 formatted identifier.</returns>
    /// <exception cref="ArgumentNullException">Thrown when certificates is null.</exception>
    /// <exception cref="ArgumentException">Thrown when chain is empty or invalid.</exception>
    public static string GenerateFromChain(IEnumerable<X509Certificate2> certificates)
    {
        if (certificates == null)
        {
            throw new ArgumentNullException(nameof(certificates));
        }

        X509Certificate2[] certArray = certificates.ToArray();

        if (certArray.Length == 0)
        {
            throw new ArgumentException("Certificate chain cannot be empty.", nameof(certificates));
        }

        X509Certificate2 leafCert = certArray[0];
        X509Certificate2 rootCert = FindRootCertificate(certArray);

        return Generate(leafCert, rootCert);
    }

    /// <summary>
    /// Finds the root certificate in a chain.
    /// </summary>
    /// <param name="certificates">The certificate chain.</param>
    /// <returns>The root certificate (self-signed certificate at the end of the chain).</returns>
    private static X509Certificate2 FindRootCertificate(X509Certificate2[] certificates)
    {
        // Look for a self-signed certificate (issuer == subject)
        X509Certificate2? rootCert = certificates.FirstOrDefault(c =>
            c.Subject.Equals(c.Issuer, StringComparison.OrdinalIgnoreCase));

        // If no self-signed cert found, use the last certificate in the chain
        return rootCert ?? certificates[certificates.Length - 1];
    }

    /// <summary>
    /// Encodes a certificate subject Distinguished Name (DN) for use in DID:X509.
    /// Per the specification, this uses percent-encoding (RFC 3986) for special characters.
    /// </summary>
    /// <param name="subject">The certificate subject DN.</param>
    /// <returns>The percent-encoded subject.</returns>
    private static string EncodeSubject(string subject)
    {
        if (string.IsNullOrEmpty(subject))
        {
            return string.Empty;
        }

        StringBuilder encoded = new StringBuilder(subject.Length * 2);

        foreach (char c in subject)
        {
            // Unreserved characters per RFC 3986: A-Z a-z 0-9 - _ . ~
            if (IsUnreservedCharacter(c))
            {
                encoded.Append(c);
            }
            else
            {
                // Percent-encode the character
                byte[] bytes = Encoding.UTF8.GetBytes(new[] { c });
                foreach (byte b in bytes)
                {
                    encoded.AppendFormat("%{0:X2}", b);
                }
            }
        }

        return encoded.ToString();
    }

    /// <summary>
    /// Checks if a character is unreserved per RFC 3986.
    /// </summary>
    private static bool IsUnreservedCharacter(char c)
    {
        return (c >= 'A' && c <= 'Z') ||
               (c >= 'a' && c <= 'z') ||
               (c >= '0' && c <= '9') ||
               c == '-' || c == '_' || c == '.' || c == '~';
    }

    /// <summary>
    /// Gets the largest (sorted) non-standard EKU OID from a certificate, if any.
    /// When multiple non-standard EKUs are present, returns the one with the largest OID value.
    /// OID comparison is done by: (1) arc depth (number of dots) descending, (2) last arc value numerically descending.
    /// Example: 1.1.1.1.1.1.1 (depth 6) > 2.1 (depth 1), and 1.2.3.999 > 1.2.3.100 (same depth, higher last arc).
    /// </summary>
    /// <param name="certificate">The certificate to check.</param>
    /// <returns>The largest non-standard EKU OID value, or null if only standard EKUs are present.</returns>
    private static string? GetNonStandardEku(X509Certificate2 certificate)
    {
        // Find the Enhanced Key Usage extension
        X509EnhancedKeyUsageExtension? ekuExtension = certificate.Extensions
            .OfType<X509EnhancedKeyUsageExtension>()
            .FirstOrDefault();

        if (ekuExtension == null)
        {
            // No EKU extension means no non-standard EKUs
            return null;
        }

        // Collect all non-standard EKU OIDs
        List<string> nonStandardEkus = new List<string>();
        foreach (Oid oid in ekuExtension.EnhancedKeyUsages)
        {
            if (oid.Value != null && !StandardEkuOids.Contains(oid.Value))
            {
                nonStandardEkus.Add(oid.Value);
            }
        }

        // Return the largest OID (sorted numerically by segments)
        return nonStandardEkus.Count > 0 
            ? nonStandardEkus.OrderByDescending(oid => oid, new OidComparer()).First()
            : null;
    }

    /// <summary>
    /// Comparer for OID strings that implements a two-phase sorting strategy:
    /// <para>1. Primary sort: Arc depth (number of segments) - descending order (deeper OIDs are considered greater)</para>
    /// <para>2. Secondary sort: Last arc value - numerically descending (when depths are equal, higher last arc wins)</para>
    /// <para>Examples:</para>
    /// <para>- Depth priority: 1.1.1.1.1.1.1 (6 dots, 7 segments) > 2.1 (1 dot, 2 segments) because 7 > 2</para>
    /// <para>- Last arc priority: 1.2.3.999 > 1.2.3.100 (both have 3 dots, but 999 > 100 in last arc)</para>
    /// <para>This algorithm ensures that OIDs with more specificity (deeper hierarchies) are preferred,</para>
    /// <para>and when specificity is equal, the numerically larger identifier takes precedence.</para>
    /// </summary>
    private class OidComparer : IComparer<string>
    {
        public int Compare(string? x, string? y)
        {
            if (x == y)
            {
                return 0;
            }

            if (x == null)
            {
                return -1;
            }

            if (y == null)
            {
                return 1;
            }

            string[] xParts = x.Split('.');
            string[] yParts = y.Split('.');

            // 1. Compare by arc depth (number of dots) - descending
            int depthComparison = xParts.Length.CompareTo(yParts.Length);
            if (depthComparison != 0)
            {
                return depthComparison; // Higher depth wins
            }

            // 2. Compare by last arc numerically - descending
            if (xParts.Length > 0 && yParts.Length > 0)
            {
                string xLast = xParts[xParts.Length - 1];
                string yLast = yParts[yParts.Length - 1];

                if (int.TryParse(xLast, out int xLastValue) && int.TryParse(yLast, out int yLastValue))
                {
                    return xLastValue.CompareTo(yLastValue); // Higher last arc wins
                }
            }

            // Fallback: lexicographic comparison
            return string.Compare(x, y, StringComparison.Ordinal);
        }
    }

    /// <summary>
    /// Validates that a string is a valid DID:X509 identifier.
    /// </summary>
    /// <param name="did">The DID to validate.</param>
    /// <returns>True if valid, false otherwise.</returns>
    public static bool IsValidDidX509(string did)
    {
        if (string.IsNullOrWhiteSpace(did))
        {
            return false;
        }

        // Must start with correct prefix
        if (!did.StartsWith(DidX509Prefix, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }

        // Must contain ::subject: or ::eku: separator
        bool hasSubject = did.Contains("::subject:", StringComparison.OrdinalIgnoreCase);
        bool hasEku = did.Contains("::eku:", StringComparison.OrdinalIgnoreCase);
        
        if (!hasSubject && !hasEku)
        {
            return false;
        }

        // Basic structure check: did:x509:0:sha256:{hash}::subject:{subject} or did:x509:0:sha256:{hash}::eku:{eku}
        string[] parts = did.Split(new[] { "::" }, StringSplitOptions.None);
        if (parts.Length != 2)
        {
            return false;
        }

        // Hash part should be hex string of appropriate length (64 chars for SHA256)
        string hashPart = parts[0].Substring(DidX509Prefix.Length + 1);
        if (hashPart.Length != 64)
        {
            return false;
        }

        // Verify hash is valid hex
        foreach (char c in hashPart)
        {
            if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))
            {
                return false;
            }
        }
        return true;
    }
}
